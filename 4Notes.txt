Shell configuration files are scripts that execute when a shell starts. The shell type determines which shell configuration files are executed.

Login shells run when the system starts and is using only the CLI as the user interface.
Non-login shells run when a shell session is opened from within the GUI. Because the user authenticated when they initially logged into the graphical environment, they are not required to log in when accessing a shell session.
The following are the names of the files used when the shell starts:

Configuration File	Description	Used by shell type
~/.bashrc	~/.bashrc stores shell preferences for individual users.	Non-login
(This file is also typically called by login shell configuration files on most distributions.)
/etc/profile	/etc/profile stores system-wide configuration commands and is used primarily to set environment variables.	Login
~/.bash_profile	~/.bash_profile stores shell preferences for individual users.	Login
~/.bash_login	~/.bash_login stores commands that execute when a user logs in.	Login
~/.profile	~/.profile stores configuration preferences similar to /etc/profile, but for individual users.	Login
~/.bash_logout	~/.bash_logout stores commands that execute when a user logs out.	Login
Login shells execute the configuration scripts they use in the following order:

/etc/profile
~/.bash_profile (If this file is found, the shell does not look for additional configuration script files.)
~/.bash_login (If this file is found, the shell does not look for additional configuration script files.)
~/.profile (This file executes only in the absence of the two preceding configuration script files.)
The su -l command switches to a user and creates a new login shell; however, without the -l option, a non-login shell is started.




As you study this section, answer the following questions:

What is the difference between redirection and piping?
When might you choose to redirect the input of a command?
What are the three default file descriptors that Linux uses to classify information for a command?
How can you overcome the 128 KB shell command size restriction?
After finishing this section, you should be able to complete the following tasks:

Redirect the standard output from the screen to a file.
Redirect and append new content to an existing file.
Redirect a standard error from a command to a file.
Redirect the standard input to a command.
Pipe the output of a command to the input of another command.
Use the pipe command to search a file for specified text.
Use the pipe command to create a text stream.
This section covers the following TestOut Linux Pro certification exam objectives:

3.0 File System Management
Create, copy, move, and delete directories in the file system.
Create, copy, move, and delete files in the file system.

Administrators often use the following methods to manipulate information created by shell commands:

Method	Description
Redirection	Redirection directs standard input, output, and error streams to locations other than the default. Be aware of the following redirection details:
By default, the Linux system classifies information with the following file descriptors:
Standard input (stdin) comes from the keyboard. Using redirection, 0 represents stdin.
Standard output (stdout) displays on the monitor. Using redirection, 1 represents stdout.
Standard errors (stderr) display on the monitor. Using redirection, 2 represents stderr.
Linux commands use the greater than symbol (>) to show redirection of output, the less than symbol arrow (<) to indicate redirection of input, and the double greater than symbol (>>) to append output to an existing file.
If you use a single greater than symbol (>) to redirect output to a file and that file already exists, its contents will be overwritten. To preserve the contents of the file, use the double greater than symbol (>>).
The tee command writes to standard output and redirects it to a file at the same time.
Piping	Piping directs the output of one command into the input of another command. Pipes:
Use the pipe symbol (|).
Can combine several commands to make a text stream.
The following table shows the results of several redirection and piping commands:

Example	Result
ls /usr > /tmp/deleteme	Writes the list of files in the /usr directory to a file named /tmp/deleteme.
ls /nonesuch > /tmp/deleteme	Does not write anything to a file and sends an error message to the monitor '/nonesuch not found' (because the directory does not exist).
ls /nonesuch 2 > /tmp/deleteme	Writes the standard error message to a file named /tmp/deleteme. This will only happen if an error message is actually generated by the command. If not, then the stderr will be null.
ls /bin /nonesuch > /tmp/deleteme	Writes the contents of the /bin directory to the /tmp/deleteme file, but sends the error message '/nonesuch not found' to the screen.
ls /bin /nonesuch > /tmp/deleteme 2>&1	Directs the standard output to the /tmp/deleteme file, then directs that the standard error messages be sent to the same place as the standard output. Both the list of files in the /bin directory and the error message are written to the same file.
ls /bin /nonesuch 2>&1 > /tmp/deleteme	Writes the contents of the /bin directory to the /tmp/deleteme file, but sends the error message '/nonesuch not found' to the screen. This is because standard error messages are directed to the same place that standard output goes, but this is before standard output has been directed to the file.
ls /bin >> /tmp/deleteme	Appends the list of files from the /usr directory on to the end of the /tmp/deleteme file.
sort < unordered_file.txt > ordered_file.txt	Takes input from the unordered_file.txt file sends it to the sort command, and then writes a new file named ordered_file.txt.
cat /usr/wordlist1 /usr/wordlist2 | sort	Sends the output of the cat command, the contents of wordlist1 and wordlist2, to the input of the sort command. The result is a sorted list of the combined contents of wordlist1 and wordlist2.
cat /usr/wordlist1 /usr/wordlist2 | mail jdoe	Mails the combined list of words in wordlist1 and wordlist2 to the user jdoe.
ls /bin | sort | mail jdoe	Lists the contents of /bin then sorts the combined contents and mails them to jdoe.
cat /usr/wordlist1 /usr/wordlist2 | sort | tee sortedwordlist	Lists the contents of wordlist1 and wordlist2 then sorts the combined contents, then sends the results to the monitor and a file named sortedwordlist.
cat /usr/wordlist1 | tee log.txt	Writes to the standard output and the log.txt file.


The bash shell allows you to use command substitution. Using command substitution, you can run a shell command and have the output from that command sent back to the command line as an argument for another shell command. Command substitution first creates a child 
process that runs the first shell command. The stdout from the first command is redirected back to the shell, which parses it into words separated by white space. After the first command has finished running, the shell starts another child process that runs the second command, using parsed output from the first command as arguments.

For example, to use the cat command to display all the files in /var that contain the text "ens32", you could enter cat $(fgrep -l ens32 /var/*). First, the fgrep -l command is run to search through all the files in the /var directory for the text string "ens32". Using the -l option with fgrep causes the command to return just a list 
of matching file names. This list of files is then sent as arguments to the cat command, which then displays the contents of each file it received from fgrep.

The xargs command reads items from the standard input and breaks up long lists of arguments into smaller, usable lists. Xargs:

Makes it easier to pipe input into commands that take arguments.
Overcomes a 128 KB shell command size restriction imposed by the Linux kernel.
Is commonly used in conjunction with the following commands:
find
ls
locate
grep -l
The following table describes the common xargs options:

Use	To	Examples
-0	Ignore space names in files.	find / -print0 -name *.odt | xargs -0 rm deletes all .odt files in the file system, even those with spaces in the file names.
-I [variable]	Replace the initial argument of a command with the argument from the standard input.	find / -name '*.jpg' | xargs -I var1 cp var1 /home/user/Pictures finds all the .jpg files on the computer and copies them into the /home/user/Pictures directory.
